<%-
model = type.map[:model].type
gen_type = type.map[:gen_type].type
mappings = type.memo['mappings'] || []
requires_context = mappings.any?(&:requires_context)
arg_def_prefix = requires_context ? 'ctx context.Context, ' : nil
arg_prefix = requires_context ? 'ctx, ' : nil

goon_model = model.fields.any?{|f| !f.tags['goon'].nil? }
model_slice = model.package.types.detect do |t|
  t.is_a?(GoonModelGen::Golang::NamedSlice) &&
  (
    (t.base_type == model) ||
    (t.base_type.is_a?(GoonModelGen::Golang::Modifier) && (t.base_type.prefix == '*') && (t.base_type.target == model) )
  )
end

plural_model_type_name = model_slice ? model_slice.qualified_name : (goon_model ? '[]*' : '[]') + model.qualified_name
-%>

func <%= gen_type.name %>SliceToModelSlice(<%= arg_def_prefix %>payloads *[]*<%= gen_type.qualified_name(dependencies) %>) (*<%= plural_model_type_name %>, error) {
	if payloads == nil {
		return nil, converters.NoPayloadGiven
	}

  s := <%= plural_model_type_name %>{}
	for _, payload := range *payloads {
		m, err := <%= gen_type.name %>ToModel(<%= arg_prefix %>payload)
		if err != nil {
			return nil, err
		}
		s = append(s, <%= goon_model ? '' : '*' %>m)
	}

	return &s, nil
}
